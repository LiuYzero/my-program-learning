### 模板方法模式

- 定义：定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现
- 模板方法使得子类可以在不改变算法的情况下，重新定义算法的某些步骤
- 类型：行为型

#### 适用场景

- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现
- 各子类中公共的行为被抽取出来并集中到一个公共父类中，从而避免代码重复

#### 优点

- 提高复用性
- 提高扩展性
- 符合开闭原则

#### 缺点

- 类数目增加
- 增加了系统实现的复杂度
- 继承关系自身缺点，如果父类增加新的抽象方法，那么所有子类都需要修改

#### 扩展

- 钩子方法

#### 相关设计模式

- 模板方法模式和工厂方法模式
- 模板方法模式和策略模式

#### 源码解读

- `AbstractList`
- `AbstractSet`
- `AbstractMap`
- `HttpServlet`
- `org.apache.ibatis.executor.BaseExecutor`

### 迭代器模式

- 定义：提供一种方法，顺序访问一个集合对象中的各个元素，而又不暴露该对象的内部表示
- 类型：行为型

#### 适用场景

- 访问一个集合对象的内容而无暴露它的内部表示
- 为遍历不同的集合结构提供一个统一的接口

#### 优点

- 分离了集合对象的遍历行为

#### 缺点

- 类的个数成对增加

#### 相关设计模式

- 迭代器模式和访问者模式

#### 源码解读

- `java.util.iterator.Iterator`
- `java.util.ArrayList.Itr`
- `org.apache.ibatis.cursor.defaults.DefaultCursor`

### 策略模式

- 定义：定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户
- 类型：行为型

#### 适用场景

- 系统有很多类，而它们的区别仅仅在于它们的行为不同
- 一个系统需要动态地在几种算法中选择一个

#### 优点

- 开闭原则
- 避免适用多重条件转移语句
- 提高算法的保密性和安全性

#### 缺点

- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类
- 产生很多策略类

#### 相关设计模式

- 策略模式和工厂模式
- 策略模式和状态模式

#### 源码解读

- `comparator`
- `Resource`
- `InstantiationStrategy`

### 解释器模式

- 定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子
- 为了解释一种语言，而为语言创建的解释器
- 类型：行为型

#### 适用场景

- 某个特定类型问题发生频率足够高

#### 优点

- 语言由很多类表示，容易改变及扩展此`语言`

#### 缺点

- 当语法规则数目太多时，增加了系统的复杂度

#### 相关设计模式

- 解释器模式和适配器模式

#### 源码分析

- `Pattern`
- `org.springframework.expression.spel.standard.SpelExpressionParser`

### 观察者模式

- 定义：定义了对象之间的一对多依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新
- 类型：行为型

#### 使用场景

- 关联行为场景，建立一套触发机制

#### 优点

- 观察者与被观察者之间建立一个抽象的耦合
- 观察者模式支持广播通信

#### 缺点

- 观察者之间由过多的细节依赖，提高时间消耗及程序复杂度
- 使用要得当，要避免循环调用

#### 源码解读

- `java.awt.Event`
- `java.util.Observable`
- `java.util.Observer`
- `java.util.EventListener`
- `com.google.common.eventbus.EventBus`

### 备忘录模式

- 定义：保存一个对象的某个状态，以便在适当的时候恢复对象
- `后悔药`
- 类型：行为型

#### 适用场景

- 保存及恢复数据相关业务场景
- 后悔的时候，即想恢复到之间的状态

#### 优点

- 为用户提供一种可恢复的机制
- 存档信息的封装

#### 缺点

- 资源占用

#### 相关设计模式

- 备忘录模式和状态模式

#### 源码解读

- `org.springframework.binding.message.StateManageableMessageContext`

### 命令模式

- 定义：将`请求`封装成对象，以便使用不同的请求
- 命令模式解决了应用程序中对象的职责以及它们之间的通信方式
- 类型：行为型

#### 适用场景

- 请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互
- 需要抽象出等待执行的行为

#### 优点

- 降低耦合
- 容易扩展新命令或者一组命令

#### 缺点

- 命令的无限扩展会增加类的数量，提高系统实现的复杂度

#### 相关设计模式

- 命令模式和备忘录模式

#### 源码解读

- `Runnable`
- `junit.framework.Test`

### 中介者模式

- 定义：定义一个封装一组对象如何交互的对象
- 通过使对象明确的相互引用来促进松散耦合，并允许独立的改变它们的交互
- 类型：行为型

#### 适用场景

- 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解
- 交互的公共行为，如果需要改变行为则可以增加新的中介者类

#### 优点

- 将一对多转化成为了一对一，降低程序的复杂度
- 类之间解耦

#### 缺点

- 中介者过多，导致系统复杂

#### 相关设计模式

- 中介者模式和观察者模式

#### 源码解读

- `java.util.Timer`

### 责任链模式

- 定义：为请求创建一个接收此次请求对象的链
- 类型：行为型

#### 适用场景

- 一个请求的处理需要多个对象当中的一个或几个协作处理

#### 优点

- 请求的发送者和接收者（请求的处理）解耦
- 责任链可以动态组合

#### 缺点

- 责任链太长或者处理时间过长，影响性能
- 责任链有可能过多

#### 相关设计模式

- 责任链模式和状态模式

#### 源码解读

- `javax.servlet.Filter#doFilter`
- `Spring Security` 

### 访问者模式

- 定义：封装作用于某数据结构（如List/Set/Map等）中的各元素的操作
- 可以在不改变各元素的类的前提下，定义作用与这些元素的操作
- 类型：行为型

#### 适用场景

- 一个数据结构如（List/Set/Map等）包含很多类型对象
- 数据结构与数据操作分离

#### 优点

- 增加新的操作很容易，即增加一个新的访问者

#### 缺点

- 增加新的数据结构困难
- 具体元素变更比较麻烦

#### 相关设计模式

- 访问者模式和迭代器模式

#### 源码解读

- `java.nio.FileVisitor`
- `BeanDefinitionVisitor`

### 状态模式

- 定义：允许一个对象在其内部状态改变时，改变它的行为
- 类型：行为型

#### 适用场景

- 一个对象存在多种状态（不同状态下行为不同），且状态可相互切换

#### 优点

- 将不同的状态隔离
- 将各种状态的转换逻辑，分布到State的子类中，减少相互间依赖
- 增加新的状态非常简单 

#### 缺点

- 状态多的业务场景导致类数目增加，系统变复杂

#### 相关设计模式

- 状态模式和享元模式

#### 源码解读

- `javax.faces.lifecycle`(jsf中的类)